const COLOR_PALETTES = { 12: [{ r: 255, g: 255, b: 255, name: '白色' }, { r: 0, g: 0, b: 0, name: '黑色' }, { r: 255, g: 0, b: 0, name: '红色' }, { r: 0, g: 255, b: 0, name: '绿色' }, { r: 0, g: 0, b: 255, name: '蓝色' }, { r: 255, g: 255, b: 0, name: '黄色' }, { r: 255, g: 165, b: 0, name: '橙色' }, { r: 128, g: 128, b: 128, name: '灰色' }, { r: 255, g: 192, b: 203, name: '粉色' }, { r: 128, g: 0, b: 128, name: '紫色' }, { r: 165, g: 42, b: 42, name: '棕色' }, { r: 0, g: 255, b: 255, name: '青色' }], 24: [{ r: 255, g: 255, b: 255, name: '白色' }, { r: 0, g: 0, b: 0, name: '黑色' }, { r: 255, g: 0, b: 0, name: '红色' }, { r: 139, g: 0, b: 0, name: '深红色' }, { r: 0, g: 255, b: 0, name: '绿色' }, { r: 0, g: 100, b: 0, name: '深绿色' }, { r: 0, g: 0, b: 255, name: '蓝色' }, { r: 0, g: 0, b: 139, name: '深蓝色' }, { r: 255, g: 255, b: 0, name: '黄色' }, { r: 255, g: 215, b: 0, name: '金色' }, { r: 255, g: 165, b: 0, name: '橙色' }, { r: 255, g: 140, b: 0, name: '深橙色' }, { r: 128, g: 128, b: 128, name: '灰色' }, { r: 169, g: 169, b: 169, name: '深灰色' }, { r: 255, g: 192, b: 203, name: '粉色' }, { r: 255, g: 20, b: 147, name: '深粉色' }, { r: 128, g: 0, b: 128, name: '紫色' }, { r: 75, g: 0, b: 130, name: '靛蓝色' }, { r: 165, g: 42, b: 42, name: '棕色' }, { r: 139, g: 69, b: 19, name: '深棕色' }, { r: 0, g: 255, b: 255, name: '青色' }, { r: 0, g: 139, b: 139, name: '深青色' }, { r: 240, g: 248, b: 255, name: '爱丽丝蓝' }, { r: 250, g: 235, b: 215, name: '古董白' }], 48: [], 72: [], 128: [] }; function generateColorPalettes() { COLOR_PALETTES[48] = [...COLOR_PALETTES[24]]; for (let i = 0; i < 24; i++) { const baseColor = COLOR_PALETTES[24][i]; COLOR_PALETTES[48].push({ r: Math.floor(baseColor.r * 0.8), g: Math.floor(baseColor.g * 0.8), b: Math.floor(baseColor.b * 0.8), name: `深${baseColor.name}` }) } COLOR_PALETTES[72] = [...COLOR_PALETTES[48]]; for (let i = 0; i < 24; i++) { const baseColor = COLOR_PALETTES[24][i]; COLOR_PALETTES[72].push({ r: Math.floor(baseColor.r * 0.6), g: Math.floor(baseColor.g * 0.6), b: Math.floor(baseColor.b * 0.6), name: `暗${baseColor.name}` }) } COLOR_PALETTES[128] = [...COLOR_PALETTES[72]]; for (let i = 0; i < 56; i++) { const h = (i * 360 / 56); const s = 70; const l = 50; const rgb = hslToRgb(h, s, l); COLOR_PALETTES[128].push({ r: rgb.r, g: rgb.g, b: rgb.b, name: `色调${i + 1}` }) } } function hslToRgb(h, s, l) { s /= 100; l /= 100; const k = n => (n + h / 30) % 12; const a = s * Math.min(l, 1 - l); const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1))); return { r: Math.round(255 * f(0)), g: Math.round(255 * f(8)), b: Math.round(255 * f(4)) } } generateColorPalettes(); let PERLER_COLORS = COLOR_PALETTES[12]; document.getElementById('colorPalette').addEventListener('change', function (e) { PERLER_COLORS = COLOR_PALETTES[e.target.value]; showColorList(); const img = document.querySelector('#upload').files[0]; if (img) { const reader = new FileReader(); reader.onload = function (e) { const image = new Image(); image.onload = function () { processImage(image) }; image.src = e.target.result }; reader.readAsDataURL(img) } });['pixelSize', 'colorPalette'].forEach(id => { document.getElementById(id).addEventListener('change', function () { const img = document.querySelector('#upload').files[0]; if (img) { const reader = new FileReader(); reader.onload = function (e) { const image = new Image(); image.onload = function () { processImage(image) }; image.src = e.target.result }; reader.readAsDataURL(img) } }) }); function findClosestColor(r, g, b) { let minDistance = Infinity; let closestColor = PERLER_COLORS[0]; for (const color of PERLER_COLORS) { const distance = Math.sqrt(Math.pow(r - color.r, 2) + Math.pow(g - color.g, 2) + Math.pow(b - color.b, 2)); if (distance < minDistance) { minDistance = distance; closestColor = color } } return closestColor } function showColorList() { const colorList = document.getElementById('colorList'); colorList.innerHTML = PERLER_COLORS.map(color => `<div class="color-item"><div class="color-dot"style="background: rgb(${color.r},${color.g},${color.b})"></div><span>${color.name}</span></div>`).join('') } showColorList(); let currentImage = null; let currentCanvas = null; function cleanupPreviousImage() { if (currentImage) { currentImage.src = ''; currentImage = null } if (currentCanvas) { currentCanvas.width = 0; currentCanvas.height = 0; currentCanvas = null } const output = document.getElementById('output'); output.innerHTML = ''; if (window.gc) window.gc() } function updateProgress(percent) { const progressBar = document.querySelector('.loading-progress-bar'); const loadingText = document.querySelector('.loading-text'); progressBar.style.width = `${percent}%`; loadingText.textContent = `处理中...${Math.round(percent)}%` } function drawGrid(canvas, width, height, scale) { const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 1; for (let x = 0; x <= width; x++) { ctx.beginPath(); ctx.moveTo(x * scale, 0); ctx.lineTo(x * scale, height * scale); ctx.stroke() } for (let y = 0; y <= height; y++) { ctx.beginPath(); ctx.moveTo(0, y * scale); ctx.lineTo(width * scale, y * scale); ctx.stroke() } } async function processImage(img) { showLoading(true); updateProgress(0); try { cleanupPreviousImage(); const pixelSize = parseInt(document.getElementById('pixelSize').value); const outputScale = Math.min(1, pixelSize / Math.max(img.width, img.height)); const width = Math.round(img.width * outputScale); const height = Math.round(img.height * outputScale); const scale = Math.max(4, Math.floor(600 / Math.max(width, height))); updateProgress(20); const previewCanvas = document.getElementById('preview-canvas'); const gridCanvas = document.getElementById('grid-canvas'); previewCanvas.width = width * scale; previewCanvas.height = height * scale; gridCanvas.width = width * scale; gridCanvas.height = height * scale; const previewCtx = previewCanvas.getContext('2d'); previewCtx.imageSmoothingEnabled = false; const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height; const tempCtx = tempCanvas.getContext('2d'); tempCtx.imageSmoothingEnabled = true; tempCtx.imageSmoothingQuality = 'high'; tempCtx.drawImage(img, 0, 0, width, height); updateProgress(40); const imageData = tempCtx.getImageData(0, 0, width, height); const data = imageData.data; const rows = new Array(height); const totalPixels = width * height; const batchSize = Math.max(100, Math.floor(totalPixels / 50)); let processedPixels = 0; function processBatch() { const endPixel = Math.min(processedPixels + batchSize, totalPixels); while (processedPixels < endPixel) { const y = Math.floor(processedPixels / width); const x = processedPixels % width; if (!rows[y]) { rows[y] = new Array(width) } const index = processedPixels * 4; const [r, g, b] = data.slice(index, index + 3); const closestColor = findClosestColor(r, g, b); rows[y][x] = `<span style="color: rgb(${closestColor.r},${closestColor.g},${closestColor.b}); background-color: rgb(${closestColor.r},${closestColor.g},${closestColor.b});"title="${closestColor.name}"></span>`; previewCtx.fillStyle = `rgb(${closestColor.r},${closestColor.g},${closestColor.b})`; const centerX = x * scale + scale / 2; const centerY = y * scale + scale / 2; const radius = (scale - 1) / 2; previewCtx.beginPath(); previewCtx.arc(centerX, centerY, radius, 0, Math.PI * 2); previewCtx.fill(); processedPixels++ } const progress = 40 + (processedPixels / totalPixels) * 60; updateProgress(progress); if (processedPixels < totalPixels) { setTimeout(processBatch, 0) } else { drawGrid(gridCanvas, width, height, scale); const output = document.getElementById('output'); output.innerHTML = rows.map(row => row.join('')).join('<br>'); document.getElementById('downloadBtn').disabled = false; showLoading(false); showStatus('图片处理完成！', 'success') } } processBatch(); currentImage = img; currentCanvas = tempCanvas } catch (error) { showLoading(false); showStatus('处理图片时出错：' + error.message, 'error'); throw error; } } function showLoading(show) { document.querySelector('.loading-overlay').style.display = show ? 'flex' : 'none' } function showStatus(message, type = 'success') { const statusEl = document.querySelector('.status-message'); statusEl.textContent = message; statusEl.className = 'status-message ' + type; statusEl.style.display = 'block'; setTimeout(() => { statusEl.style.display = 'none' }, 3000) } document.getElementById('downloadBtn').addEventListener('click', function () { const canvas = document.getElementById('preview-canvas'); const link = document.createElement('a'); link.download = '拼豆豆图案.png'; link.href = canvas.toDataURL(); link.click() }); function showError(message) { document.getElementById('error').textContent = message } document.getElementById('upload').addEventListener('change', async function (event) { const file = event.target.files[0]; if (!file) return; if (!file.type.startsWith('image/')) { showStatus('请上传图片文件', 'error'); return } const maxSize = 10 * 1024 * 1024; if (file.size > maxSize) { showStatus('图片大小不能超过10MB', 'error'); return } try { showLoading(true); cleanupPreviousImage(); const img = new Image(); const reader = new FileReader(); const loadImage = new Promise((resolve, reject) => { img.onload = () => resolve(img); img.onerror = () => reject(new Error('图片加载失败')) }); reader.onload = (e) => img.src = e.target.result; reader.onerror = () => showStatus('文件读取失败', 'error'); reader.readAsDataURL(file); const loadedImg = await loadImage; await processImage(loadedImg) } catch (error) { showStatus(error.message, 'error') } }); document.getElementById('pixelSize').addEventListener('input', function (e) { document.getElementById('pixelSizeValue').textContent = e.target.value });